use crate::{
    config::EventListenerConfig,
    error::{EventListenerError, Result},
    parser::{EventParser, ParsedEvent},
};
use async_trait::async_trait;
use base64::{engine::general_purpose, Engine as _};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};
use solana_sdk::pubkey::Pubkey;
use tracing::{debug, info, warn};

/// ‰∫§Êç¢‰∫ã‰ª∂ÁöÑÂéüÂßãÊï∞ÊçÆÁªìÊûÑÔºà‰∏éÊúÄÊñ∞Êô∫ËÉΩÂêàÁ∫¶‰øùÊåÅ‰∏ÄËá¥Ôºâ
/// ÊúÄÊñ∞ÁöÑSwapEventÁªìÊûÑ‰ΩìÔºàÈúÄÊ±Ç‰∏≠Êèê‰æõÁöÑÊñ∞ÁâàÊú¨Ôºâ
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SwapEvent {
    /// ÊîØ‰ªòËÄÖ/‰∫§Êç¢ÂèëËµ∑ËÄÖ
    pub payer: Pubkey,
    /// Ê±†Â≠êID
    pub pool_id: Pubkey,
    /// ËæìÂÖ•ÈáëÂ∫ì‰ΩôÈ¢ùÔºàÊâ£Èô§‰∫§ÊòìË¥πÂêéÔºâ
    pub input_vault_before: u64,
    /// ËæìÂá∫ÈáëÂ∫ì‰ΩôÈ¢ùÔºàÊâ£Èô§‰∫§ÊòìË¥πÂêéÔºâ
    pub output_vault_before: u64,
    /// ËæìÂÖ•Êï∞ÈáèÔºà‰∏çÂê´ËΩ¨Ë¥¶Ë¥πÔºâ
    pub input_amount: u64,
    /// ËæìÂá∫Êï∞ÈáèÔºà‰∏çÂê´ËΩ¨Ë¥¶Ë¥πÔºâ
    pub output_amount: u64,
    /// ËæìÂÖ•ËΩ¨Ë¥¶Ë¥π
    pub input_transfer_fee: u64,
    /// ËæìÂá∫ËΩ¨Ë¥¶Ë¥π
    pub output_transfer_fee: u64,
    /// ÊòØÂê¶ÊòØÂü∫Á°Ä‰ª£Â∏ÅËæìÂÖ•
    pub base_input: bool,
    /// ËæìÂÖ•‰ª£Â∏ÅmintÂú∞ÂùÄ
    pub input_mint: Pubkey,
    /// ËæìÂá∫‰ª£Â∏ÅmintÂú∞ÂùÄ
    pub output_mint: Pubkey,
    /// ‰∫§ÊòìÊâãÁª≠Ë¥π
    pub trade_fee: u64,
    /// ÂàõÂª∫ËÄÖË¥πÁî®
    pub creator_fee: u64,
    /// ÂàõÂª∫ËÄÖË¥πÁî®ÊòØÂê¶Âú®ËæìÂÖ•‰ª£Â∏Å‰∏ä
    pub creator_fee_on_input: bool,
}

/// ‰∫§Êç¢‰∫ã‰ª∂Êï∞ÊçÆÔºàÁî®‰∫é‰∫ã‰ª∂Á≥ªÁªü‰º†ÈÄíÔºâ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapEventData {
    /// ÊîØ‰ªòËÄÖ/‰∫§Êç¢ÂèëËµ∑ËÄÖ
    pub payer: String,
    /// Ê±†Â≠êÂú∞ÂùÄ
    pub pool_id: String,
    /// ËæìÂÖ•ÈáëÂ∫ì‰ΩôÈ¢ùÔºàÊâ£Èô§‰∫§ÊòìË¥πÂêéÔºâ
    pub input_vault_before: u64,
    /// ËæìÂá∫ÈáëÂ∫ì‰ΩôÈ¢ùÔºàÊâ£Èô§‰∫§ÊòìË¥πÂêéÔºâ
    pub output_vault_before: u64,
    /// ËæìÂÖ•Êï∞ÈáèÔºà‰∏çÂê´ËΩ¨Ë¥¶Ë¥πÔºâ
    pub input_amount: u64,
    /// ËæìÂá∫Êï∞ÈáèÔºà‰∏çÂê´ËΩ¨Ë¥¶Ë¥πÔºâ
    pub output_amount: u64,
    /// ËæìÂÖ•ËΩ¨Ë¥¶Ë¥π
    pub input_transfer_fee: u64,
    /// ËæìÂá∫ËΩ¨Ë¥¶Ë¥π
    pub output_transfer_fee: u64,
    /// ÊòØÂê¶ÊòØÂü∫Á°Ä‰ª£Â∏ÅËæìÂÖ•
    pub base_input: bool,
    /// ËæìÂÖ•‰ª£Â∏ÅmintÂú∞ÂùÄ
    pub input_mint: String,
    /// ËæìÂá∫‰ª£Â∏ÅmintÂú∞ÂùÄ
    pub output_mint: String,
    /// ‰∫§ÊòìÊâãÁª≠Ë¥π
    pub trade_fee: u64,
    /// ÂàõÂª∫ËÄÖË¥πÁî®
    pub creator_fee: u64,
    /// ÂàõÂª∫ËÄÖË¥πÁî®ÊòØÂê¶Âú®ËæìÂÖ•‰ª£Â∏Å‰∏ä
    pub creator_fee_on_input: bool,
    /// ‰∫§ÊòìÁ≠æÂêç
    pub signature: String,
    /// Âå∫ÂùóÈ´òÂ∫¶
    pub slot: u64,
    /// Â§ÑÁêÜÊó∂Èó¥
    pub processed_at: String,
}
/// ‰∫§Êç¢‰∫ã‰ª∂Ëß£ÊûêÂô®
pub struct SwapParser {
    /// ‰∫ã‰ª∂ÁöÑdiscriminator
    discriminator: [u8; 8],
    /// ÁõÆÊ†áÁ®ãÂ∫èIDÔºåÊåáÂÆöÊ≠§Ëß£ÊûêÂô®Â§ÑÁêÜÂì™‰∏™Á®ãÂ∫èÁöÑ‰∫ã‰ª∂
    target_program_id: Pubkey,
}

impl SwapParser {
    /// ÂàõÂª∫Êñ∞ÁöÑ‰∫§Êç¢‰∫ã‰ª∂Ëß£ÊûêÂô®
    pub fn new(_config: &EventListenerConfig, program_id: Pubkey) -> Result<Self> {
        // Ê†πÊçÆËÆæËÆ°ÊñáÊ°£Ôºå‰ΩøÁî®‰∫ã‰ª∂Á±ªÂûãÂêçÁß∞ËÆ°ÁÆódiscriminator
        let discriminator = crate::parser::event_parser::calculate_event_discriminator("SwapEvent");

        Ok(Self {
            discriminator,
            target_program_id: program_id,
        })
    }

    /// ‰ªéÁ®ãÂ∫èÊï∞ÊçÆËß£Êûê‰∫§Êç¢‰∫ã‰ª∂
    fn parse_program_data(&self, data_str: &str) -> Result<SwapEvent> {
        // Base64Ëß£Á†Å
        let data = general_purpose::STANDARD
            .decode(data_str)
            .map_err(|e| EventListenerError::EventParsing(format!("Base64Ëß£Á†ÅÂ§±Ë¥•: {}", e)))?;

        if data.len() < 8 {
            return Err(EventListenerError::EventParsing(
                "Êï∞ÊçÆÈïøÂ∫¶‰∏çË∂≥ÔºåÊó†Ê≥ïÂåÖÂê´discriminator".to_string(),
            ));
        }

        // È™åËØÅdiscriminator
        let discriminator = &data[0..8];
        if discriminator != self.discriminator {
            return Err(EventListenerError::DiscriminatorMismatch);
        }

        // BorshÂèçÂ∫èÂàóÂåñ‰∫ã‰ª∂Êï∞ÊçÆ
        let event_data = &data[8..];
        let event = SwapEvent::try_from_slice(event_data)
            .map_err(|e| EventListenerError::EventParsing(format!("BorshÂèçÂ∫èÂàóÂåñÂ§±Ë¥•: {}", e)))?;

        debug!(
            "‚úÖ ÊàêÂäüËß£Êûê‰∫§Êç¢‰∫ã‰ª∂: Ê±†Â≠ê={}, ÂèëÈÄÅËÄÖ={}, input={}, output={}",
            event.pool_id, event.payer, event.input_amount, event.output_amount
        );
        Ok(event)
    }

    /// Â∞ÜÂéüÂßã‰∫ã‰ª∂ËΩ¨Êç¢‰∏∫SwapEventData
    fn convert_to_parsed_event(&self, event: SwapEvent, signature: String, slot: u64) -> ParsedEvent {
        ParsedEvent::Swap(SwapEventData {
            payer: event.payer.to_string(),
            pool_id: event.pool_id.to_string(),
            input_vault_before: event.input_vault_before,
            output_vault_before: event.output_vault_before,
            input_amount: event.input_amount,
            output_amount: event.output_amount,
            input_transfer_fee: event.input_transfer_fee,
            output_transfer_fee: event.output_transfer_fee,
            base_input: event.base_input,
            input_mint: event.input_mint.to_string(),
            output_mint: event.output_mint.to_string(),
            trade_fee: event.trade_fee,
            creator_fee: event.creator_fee,
            creator_fee_on_input: event.creator_fee_on_input,
            signature,
            slot,
            processed_at: chrono::Utc::now().to_rfc3339(),
        })
    }

    /// È™åËØÅ‰∫§Êç¢‰∫ã‰ª∂Êï∞ÊçÆ
    fn validate_swap(&self, event: &SwapEvent) -> Result<bool> {
        // È™åËØÅÊ±†Â≠êÂú∞ÂùÄ
        if event.pool_id == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑÊ±†Â≠êÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅÊîØ‰ªòËÄÖÂú∞ÂùÄ
        if event.payer == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑÊîØ‰ªòËÄÖÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅËæìÂÖ•ËæìÂá∫‰ª£Â∏ÅÂú∞ÂùÄ
        if event.input_mint == Pubkey::default() || event.output_mint == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑ‰ª£Â∏ÅmintÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅ‰∫§Êç¢Êï∞Èáè
        if event.input_amount == 0 && event.output_amount == 0 {
            warn!("‚ùå ËæìÂÖ•ÂíåËæìÂá∫Êï∞Èáè‰∏çËÉΩÂêåÊó∂‰∏∫0");
            return Ok(false);
        }

        Ok(true)
    }
}

#[async_trait]
impl EventParser for SwapParser {
    fn get_program_id(&self) -> Pubkey {
        self.target_program_id
    }

    fn get_discriminator(&self) -> [u8; 8] {
        self.discriminator
    }

    fn get_event_type(&self) -> &'static str {
        "swap"
    }

    fn supports_program(&self, program_id: &Pubkey) -> Option<bool> {
        Some(*program_id == self.target_program_id)
    }

    async fn parse_from_logs(&self, logs: &[String], signature: &str, slot: u64) -> Result<Option<ParsedEvent>> {
        for (index, log) in logs.iter().enumerate() {
            if log.starts_with("Program data: ") {
                if let Some(data_part) = log.strip_prefix("Program data: ") {
                    match self.parse_program_data(data_part) {
                        Ok(event) => {
                            info!(
                                "üí± Á¨¨{}Ë°åÂèëÁé∞‰∫§Êç¢‰∫ã‰ª∂: Ê±†Â≠ê={}, ‰∫§Êç¢ËÄÖ={}, ËæìÂÖ•={}, ËæìÂá∫={}",
                                index + 1,
                                event.pool_id,
                                event.payer,
                                event.input_amount,
                                event.output_amount
                            );

                            if self.validate_swap(&event)? {
                                let parsed_event = self.convert_to_parsed_event(event, signature.to_string(), slot);
                                return Ok(Some(parsed_event));
                            }
                        }
                        Err(EventListenerError::DiscriminatorMismatch) => {
                            // Discriminator‰∏çÂåπÈÖçÊòØÊ≠£Â∏∏ÊÉÖÂÜµÔºåÁªßÁª≠Â∞ùËØï‰∏ã‰∏ÄÊù°Êó•Âøó
                            continue;
                        }
                        Err(e) => {
                            debug!("‚ö†Ô∏è Á¨¨{}Ë°å‰∫§Êç¢‰∫ã‰ª∂Ëß£ÊûêÂ§±Ë¥•: {}", index + 1, e);
                            continue;
                        }
                    }
                }
            }
        }
        Ok(None)
    }

    async fn validate_event(&self, event: &ParsedEvent) -> Result<bool> {
        match event {
            ParsedEvent::Swap(_) => Ok(true),
            _ => Ok(false),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::parser::token_creation_parser::TokenCreationEventData;

    use super::*;
    use borsh::BorshDeserialize;
    use solana_sdk::pubkey::Pubkey;
    use std::str::FromStr;

    fn create_test_config() -> EventListenerConfig {
        EventListenerConfig {
            solana: crate::config::settings::SolanaConfig {
                rpc_url: "https://api.devnet.solana.com".to_string(),
                ws_url: "wss://api.devnet.solana.com".to_string(),
                commitment: "confirmed".to_string(),
                program_ids: vec![Pubkey::from_str("FA1RJDDXysgwg5Gm3fJXWxt26JQzPkAzhTA114miqNUX").unwrap()],
                private_key: None,
            },
            database: crate::config::settings::DatabaseConfig {
                uri: "mongodb://localhost:27017".to_string(),
                database_name: "test".to_string(),
                max_connections: 10,
                min_connections: 2,
            },
            listener: crate::config::settings::ListenerConfig {
                batch_size: 100,
                sync_interval_secs: 30,
                max_retries: 3,
                retry_delay_ms: 1000,
                signature_cache_size: 10000,
                checkpoint_save_interval_secs: 60,
                backoff: crate::config::settings::BackoffConfig::default(),
                batch_write: crate::config::settings::BatchWriteConfig::default(),
            },
            monitoring: crate::config::settings::MonitoringConfig {
                metrics_interval_secs: 60,
                enable_performance_monitoring: true,
                health_check_interval_secs: 30,
            },
            backfill: None,
        }
    }

    #[test]
    fn test_manual_swap_event_parsing() {
        // ÂÆûÈôÖ‰∫§Êç¢‰∫ã‰ª∂ÁöÑProgram dataÊ†∑Êú¨
        let program_data_samples = vec![
            "QMbN6CYIceLMGVG4MU+4ATrjvnYksJMPuMJgCPDP1rdRiKjoj6HsZW5rIlaQU+bQ2trw/mEw5Ts8MT5LpaWvcjF+jxy32bzweGbf5NhXXDsAo6eSe6tqrro9sQFopURaKkodvL3GGqAbpd/JYbZV98UXob/ADOEQw+2rDIEszGzDveqoHB9EswjsDgAAAAAAAAAAAAAAAABAQg8AAAAAAAAAAAAAAAAAAOBhVPT8qoQCAQAAAAAAAABPO8PfAAAAAAAAAAAAAAAAwwAAAA==",
        ];

        let expected_swap_discriminator = crate::parser::event_parser::calculate_event_discriminator("SwapEvent");

        for (i, data_str) in program_data_samples.iter().enumerate() {
            println!("=== ÊµãËØï Program data {} ===", i + 1);
            println!("Base64Êï∞ÊçÆ: {}...", &data_str[..50]);

            // Ëß£Á†ÅBase64Êï∞ÊçÆ
            use base64::{engine::general_purpose, Engine as _};
            match general_purpose::STANDARD.decode(data_str) {
                Ok(data) => {
                    println!("Ëß£Á†ÅÂêéÊï∞ÊçÆÈïøÂ∫¶: {} bytes", data.len());

                    if data.len() < 8 {
                        println!("‚ùå Êï∞ÊçÆÈïøÂ∫¶‰∏çË∂≥ÔºåÊó†Ê≥ïÂåÖÂê´discriminator");
                        continue;
                    }

                    // Ê£ÄÊü•discriminator
                    let discriminator = &data[0..8];
                    println!("ÂÆûÈôÖdiscriminator: {:?}", discriminator);
                    println!("ÊúüÊúõdiscriminator: {:?}", expected_swap_discriminator);

                    if discriminator == expected_swap_discriminator {
                        println!("‚úÖ DiscriminatorÂåπÈÖçÔºåÂ∞ùËØïËß£ÊûêSwapEvent");

                        // Â∞ùËØïËß£ÊûêSwapEvent
                        let event_data = &data[8..];
                        match SwapEvent::try_from_slice(event_data) {
                            Ok(swap_event) => {
                                println!("‚úÖ ÊàêÂäüËß£ÊûêSwap‰∫ã‰ª∂ÔºÅ");
                                println!("üîç Payer: {}", swap_event.payer);
                                println!("üîç Pool ID: {}", swap_event.pool_id);
                                println!("üîç Input Amount: {}", swap_event.input_amount);
                                println!("üîç Output Amount: {}", swap_event.output_amount);
                                println!("üîç Input Mint: {}", swap_event.input_mint);
                                println!("üîç Output Mint: {}", swap_event.output_mint);
                                println!("üîç Base Input: {}", swap_event.base_input);
                                println!("üîç Trade Fee: {}", swap_event.trade_fee);

                                // È™åËØÅÂÖ≥ÈîÆÂ≠óÊÆµÂêàÁêÜÊÄß
                                assert!(!swap_event.pool_id.to_string().is_empty());
                                assert!(!swap_event.payer.to_string().is_empty());
                                println!("‚úÖ SwapEventÂ≠óÊÆµÈ™åËØÅÈÄöËøá");
                            }
                            Err(e) => {
                                println!("‚ùå SwapEventËß£ÊûêÂ§±Ë¥•: {}", e);
                                println!("‰∫ã‰ª∂Êï∞ÊçÆÈïøÂ∫¶: {} bytes", event_data.len());
                                // ÊâìÂç∞Ââç32Â≠óËäÇÁöÑÂçÅÂÖ≠ËøõÂà∂Êï∞ÊçÆÁî®‰∫éË∞ÉËØï
                                let hex_data = event_data
                                    .iter()
                                    .take(32)
                                    .map(|b| format!("{:02x}", b))
                                    .collect::<Vec<_>>()
                                    .join(" ");
                                println!("‰∫ã‰ª∂Êï∞ÊçÆÂâç32Â≠óËäÇ: {}", hex_data);
                            }
                        }
                    } else {
                        println!("‚ùå Discriminator‰∏çÂåπÈÖçÔºåË∑≥ËøáËß£Êûê");
                    }
                }
                Err(e) => {
                    println!("‚ùå Base64Ëß£Á†ÅÂ§±Ë¥•: {}", e);
                }
            }
            println!();
        }
    }

    #[test]
    fn test_swap_parser_creation() {
        let config = create_test_config();
        let parser = SwapParser::new(&config, Pubkey::new_unique()).unwrap();

        assert_eq!(parser.get_event_type(), "swap");
        assert_eq!(
            parser.get_discriminator(),
            crate::parser::event_parser::calculate_event_discriminator("SwapEvent")
        );
    }

    #[test]
    fn test_swap_parser_supports_program() {
        let config = create_test_config();
        let target_program = Pubkey::from_str("FA1RJDDXysgwg5Gm3fJXWxt26JQzPkAzhTA114miqNUX").unwrap();
        let parser = SwapParser::new(&config, target_program).unwrap();

        // Â∫îËØ•ÊîØÊåÅÁõÆÊ†áÁ®ãÂ∫è
        assert_eq!(parser.supports_program(&target_program), Some(true));

        // ‰∏çÂ∫îËØ•ÊîØÊåÅÂÖ∂‰ªñÁ®ãÂ∫è
        let other_program = Pubkey::new_unique();
        assert_eq!(parser.supports_program(&other_program), Some(false));
    }

    #[tokio::test]
    async fn test_parse_from_logs_no_program_data() {
        let config = create_test_config();
        let parser = SwapParser::new(&config, Pubkey::new_unique()).unwrap();

        let logs = vec![
            "Program 11111111111111111111111111111111 invoke [1]".to_string(),
            "Program 11111111111111111111111111111111 success".to_string(),
        ];

        let result = parser.parse_from_logs(&logs, "test_sig", 12345).await.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn test_validate_event() {
        let config = create_test_config();
        let parser = SwapParser::new(&config, Pubkey::new_unique()).unwrap();

        // ÂàõÂª∫ÊµãËØï‰∫§Êç¢‰∫ã‰ª∂
        let swap_event = ParsedEvent::Swap(SwapEventData {
            payer: Pubkey::new_unique().to_string(),
            pool_id: Pubkey::new_unique().to_string(),
            input_vault_before: 1000000,
            output_vault_before: 2000000,
            input_amount: 1000000,
            output_amount: 2000000,
            input_transfer_fee: 1000,
            output_transfer_fee: 2000,
            base_input: true,
            input_mint: Pubkey::new_unique().to_string(),
            output_mint: Pubkey::new_unique().to_string(),
            trade_fee: 3000,
            creator_fee: 500,
            creator_fee_on_input: true,
            signature: "test_sig".to_string(),
            slot: 12345,
            processed_at: chrono::Utc::now().to_rfc3339(),
        });

        assert!(parser.validate_event(&swap_event).await.unwrap());

        // ÊµãËØïÂÖ∂‰ªñÁ±ªÂûãÁöÑ‰∫ã‰ª∂Â∫îËØ•ËøîÂõûfalse
        let token_event = ParsedEvent::TokenCreation(TokenCreationEventData {
            project_config: Pubkey::new_unique().to_string(),
            mint_address: Pubkey::new_unique().to_string(),
            name: "Test".to_string(),
            symbol: "TEST".to_string(),
            metadata_uri: "https://example.com".to_string(),
            logo_uri: "https://example.com/logo.png".to_string(),
            decimals: 9,
            supply: 1000000,
            creator: Pubkey::new_unique().to_string(),
            has_whitelist: false,
            whitelist_deadline: 0,
            created_at: 1234567890,
            signature: "test_sig".to_string(),
            slot: 12345,
            extensions: None,
            source: None,
        });

        assert!(!parser.validate_event(&token_event).await.unwrap());
    }
}

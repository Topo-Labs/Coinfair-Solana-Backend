use crate::{
    config::EventListenerConfig,
    error::{EventListenerError, Result},
    parser::{event_parser::PoolCreationEventData, EventParser, ParsedEvent},
};
use async_trait::async_trait;
use base64::{engine::general_purpose, Engine as _};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_sdk::pubkey::Pubkey;
use tracing::{debug, info, warn};

/// Ê±†Â≠êÂàõÂª∫‰∫ã‰ª∂ÁöÑÂéüÂßãÊï∞ÊçÆÁªìÊûÑÔºà‰∏éRaydium CLMMÊô∫ËÉΩÂêàÁ∫¶‰øùÊåÅ‰∏ÄËá¥Ôºâ
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct PoolCreationEvent {
    /// CLMMÊ±†Â≠êÂú∞ÂùÄ
    pub pool_address: Pubkey,
    /// ‰ª£Â∏ÅAÁöÑmintÂú∞ÂùÄ
    pub token_a_mint: Pubkey,
    /// ‰ª£Â∏ÅBÁöÑmintÂú∞ÂùÄ  
    pub token_b_mint: Pubkey,
    /// ‰ª£Â∏ÅAÁöÑÂ∞èÊï∞‰ΩçÊï∞
    pub token_a_decimals: u8,
    /// ‰ª£Â∏ÅBÁöÑÂ∞èÊï∞‰ΩçÊï∞
    pub token_b_decimals: u8,
    /// ÊâãÁª≠Ë¥πÁéá (Âçï‰Ωç: ‰∏áÂàÜ‰πã‰∏Ä, Â¶Ç3000Ë°®Á§∫0.3%)
    pub fee_rate: u32,
    /// ÂàùÂßãsqrt‰ª∑Ê†º
    pub sqrt_price_x64: u128,
    /// ÂàùÂßãtick
    pub tick: i32,
    /// Ê±†Â≠êÂàõÂª∫ËÄÖ
    pub creator: Pubkey,
    /// CLMMÈÖçÁΩÆÂú∞ÂùÄ
    pub clmm_config: Pubkey,
    /// ÂàõÂª∫Êó∂Èó¥Êà≥
    pub created_at: i64,
}

/// Ê±†Â≠êÂàõÂª∫‰∫ã‰ª∂Ëß£ÊûêÂô®
pub struct PoolCreationParser {
    /// ‰∫ã‰ª∂ÁöÑdiscriminatorÔºà‰ªéRaydium CLMM IDLËé∑ÂèñÔºâ
    discriminator: [u8; 8],
}

impl PoolCreationParser {
    /// ÂàõÂª∫Êñ∞ÁöÑÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂Ëß£ÊûêÂô®
    pub fn new(_config: &EventListenerConfig) -> Result<Self> {
        // Raydium CLMM PoolCreated‰∫ã‰ª∂ÁöÑdiscriminator
        // Ê≥®ÊÑèÔºöÂÆûÈôÖÈÉ®ÁΩ≤Êó∂ÈúÄË¶Å‰ªéRaydium IDLËé∑ÂèñÊ≠£Á°ÆÁöÑdiscriminator
        let discriminator = [89, 202, 187, 172, 108, 193, 190, 8];

        Ok(Self { discriminator })
    }

    /// ‰ªéÁ®ãÂ∫èÊï∞ÊçÆËß£ÊûêÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂
    fn parse_program_data(&self, data_str: &str) -> Result<PoolCreationEvent> {
        // Base64Ëß£Á†Å
        let data = general_purpose::STANDARD
            .decode(data_str)
            .map_err(|e| EventListenerError::EventParsing(format!("Base64Ëß£Á†ÅÂ§±Ë¥•: {}", e)))?;

        if data.len() < 8 {
            return Err(EventListenerError::EventParsing("Êï∞ÊçÆÈïøÂ∫¶‰∏çË∂≥ÔºåÊó†Ê≥ïÂåÖÂê´discriminator".to_string()));
        }

        // È™åËØÅdiscriminator
        let discriminator = &data[0..8];
        if discriminator != self.discriminator {
            return Err(EventListenerError::DiscriminatorMismatch);
        }

        // BorshÂèçÂ∫èÂàóÂåñ‰∫ã‰ª∂Êï∞ÊçÆ
        let event_data = &data[8..];
        let event = PoolCreationEvent::try_from_slice(event_data).map_err(|e| EventListenerError::EventParsing(format!("BorshÂèçÂ∫èÂàóÂåñÂ§±Ë¥•: {}", e)))?;

        debug!("‚úÖ ÊàêÂäüËß£ÊûêÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂: Ê±†Â≠ê={}, ‰ª£Â∏ÅÂØπ={}/{}", event.pool_address, event.token_a_mint, event.token_b_mint);
        Ok(event)
    }

    /// ËÆ°ÁÆóÊ±†Â≠êÁõ∏ÂÖ≥ÊåáÊ†á
    fn calculate_pool_metrics(&self, event: &PoolCreationEvent) -> (f64, f64, String) {
        // ËÆ°ÁÆó‰ª∑Ê†º (‰ªésqrt_price_x64ÂèçÊé®)
        let price_ratio = if event.sqrt_price_x64 > 0 {
            let sqrt_price = event.sqrt_price_x64 as f64 / (1u128 << 64) as f64;
            sqrt_price * sqrt_price
        } else {
            0.0
        };

        // ËÆ°ÁÆóÂπ¥ÂåñÊâãÁª≠Ë¥πÁéá
        let annual_fee_rate = (event.fee_rate as f64 / 10000.0) * 365.0; // ÂÅáËÆæÊØèÂ§©‰∫§Êòì‰∏ÄÊ¨°

        // Á°ÆÂÆöÊ±†Â≠êÁ±ªÂûã
        let pool_type = match event.fee_rate {
            100 => "Ë∂Ö‰ΩéË¥πÁéá".to_string(),  // 0.01%
            500 => "‰ΩéË¥πÁéá".to_string(),    // 0.05%
            2500 => "Ê†áÂáÜË¥πÁéá".to_string(), // 0.25%
            3000 => "Ê†áÂáÜË¥πÁéá".to_string(), // 0.3%
            10000 => "È´òË¥πÁéá".to_string(),  // 1%
            _ => format!("Ëá™ÂÆö‰πâË¥πÁéá({})", event.fee_rate as f64 / 10000.0),
        };

        (price_ratio, annual_fee_rate, pool_type)
    }

    /// Â∞ÜÂéüÂßã‰∫ã‰ª∂ËΩ¨Êç¢‰∏∫ParsedEvent
    fn convert_to_parsed_event(&self, event: PoolCreationEvent, signature: String, slot: u64) -> ParsedEvent {
        let (initial_price, annual_fee_rate, pool_type) = self.calculate_pool_metrics(&event);

        ParsedEvent::PoolCreation(PoolCreationEventData {
            pool_address: event.pool_address,
            token_a_mint: event.token_a_mint,
            token_b_mint: event.token_b_mint,
            token_a_decimals: event.token_a_decimals,
            token_b_decimals: event.token_b_decimals,
            fee_rate: event.fee_rate,
            fee_rate_percentage: event.fee_rate as f64 / 10000.0,
            annual_fee_rate,
            pool_type,
            sqrt_price_x64: event.sqrt_price_x64,
            initial_price,
            initial_tick: event.tick,
            creator: event.creator,
            clmm_config: event.clmm_config,
            is_stable_pair: false,        // ÈúÄË¶ÅÈÄöËøá‰ª£Â∏ÅÂàÜÊûêÁ°ÆÂÆö
            estimated_liquidity_usd: 0.0, // ÂàõÂª∫Êó∂ÊöÇÊó†ÊµÅÂä®ÊÄß
            created_at: event.created_at,
            signature,
            slot,
            processed_at: chrono::Utc::now().to_rfc3339(),
        })
    }

    /// È™åËØÅÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂Êï∞ÊçÆ
    fn validate_pool_creation(&self, event: &PoolCreationEventData) -> Result<bool> {
        // È™åËØÅÊ±†Â≠êÂú∞ÂùÄ
        if event.pool_address == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑÊ±†Â≠êÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅ‰ª£Â∏ÅÂú∞ÂùÄ
        if event.token_a_mint == Pubkey::default() || event.token_b_mint == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ: {} Êàñ {}", event.token_a_mint, event.token_b_mint);
            return Ok(false);
        }

        // È™åËØÅ‰ª£Â∏Å‰∏çËÉΩÁõ∏Âêå
        if event.token_a_mint == event.token_b_mint {
            warn!("‚ùå ‰ª£Â∏ÅAÂíå‰ª£Â∏ÅB‰∏çËÉΩÁõ∏Âêå: {}", event.token_a_mint);
            return Ok(false);
        }

        // È™åËØÅÂ∞èÊï∞‰ΩçÊï∞ÂêàÁêÜÊÄß
        if event.token_a_decimals > 18 || event.token_b_decimals > 18 {
            warn!("‚ùå ‰ª£Â∏ÅÂ∞èÊï∞‰ΩçÊï∞Ë∂ÖÂá∫ÂêàÁêÜËåÉÂõ¥: A={}, B={}", event.token_a_decimals, event.token_b_decimals);
            return Ok(false);
        }

        // È™åËØÅÊâãÁª≠Ë¥πÁéáÂêàÁêÜÊÄß (0.01% - 10%)
        if event.fee_rate == 0 || event.fee_rate > 100000 {
            warn!("‚ùå ÊâãÁª≠Ë¥πÁéá‰∏çÂêàÁêÜ: {}", event.fee_rate);
            return Ok(false);
        }

        // È™åËØÅsqrt‰ª∑Ê†º
        if event.sqrt_price_x64 == 0 {
            warn!("‚ùå sqrt‰ª∑Ê†º‰∏çËÉΩ‰∏∫0");
            return Ok(false);
        }

        // È™åËØÅÂàõÂª∫ËÄÖÂú∞ÂùÄ
        if event.creator == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑÂàõÂª∫ËÄÖÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅCLMMÈÖçÁΩÆÂú∞ÂùÄ
        if event.clmm_config == Pubkey::default() {
            warn!("‚ùå Êó†ÊïàÁöÑCLMMÈÖçÁΩÆÂú∞ÂùÄ");
            return Ok(false);
        }

        // È™åËØÅÊó∂Èó¥Êà≥ÂêàÁêÜÊÄß
        let now = chrono::Utc::now().timestamp();
        if event.created_at > now || event.created_at < (now - 86400) {
            warn!("‚ùå ÂàõÂª∫Êó∂Èó¥Êà≥ÂºÇÂ∏∏: {}", event.created_at);
            return Ok(false);
        }

        // È™åËØÅtickËåÉÂõ¥ (Raydium CLMMÁöÑtickËåÉÂõ¥)
        if event.initial_tick < -887272 || event.initial_tick > 887272 {
            warn!("‚ùå ÂàùÂßãtickË∂ÖÂá∫ËåÉÂõ¥: {}", event.initial_tick);
            return Ok(false);
        }

        Ok(true)
    }
}

#[async_trait]
impl EventParser for PoolCreationParser {
    fn get_discriminator(&self) -> [u8; 8] {
        self.discriminator
    }

    fn get_event_type(&self) -> &'static str {
        "pool_creation"
    }

    async fn parse_from_logs(&self, logs: &[String], signature: &str, slot: u64) -> Result<Option<ParsedEvent>> {
        for (index, log) in logs.iter().enumerate() {
            if log.starts_with("Program data: ") {
                if let Some(data_part) = log.strip_prefix("Program data: ") {
                    match self.parse_program_data(data_part) {
                        Ok(event) => {
                            info!("üèä Á¨¨{}Ë°åÂèëÁé∞Ê±†Â≠êÂàõÂª∫‰∫ã‰ª∂: {} (Ë¥πÁéá: {}%)", index + 1, event.pool_address, event.fee_rate as f64 / 10000.0);
                            let parsed_event = self.convert_to_parsed_event(event, signature.to_string(), slot);
                            return Ok(Some(parsed_event));
                        }
                        Err(EventListenerError::DiscriminatorMismatch) => {
                            // Discriminator‰∏çÂåπÈÖçÊòØÊ≠£Â∏∏ÊÉÖÂÜµÔºåÁªßÁª≠Â∞ùËØï‰∏ã‰∏ÄÊù°Êó•Âøó
                            continue;
                        }
                        Err(e) => {
                            debug!("‚ö†Ô∏è Á¨¨{}Ë°åÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂Ëß£ÊûêÂ§±Ë¥•: {}", index + 1, e);
                            continue;
                        }
                    }
                }
            }
        }
        Ok(None)
    }

    async fn validate_event(&self, event: &ParsedEvent) -> Result<bool> {
        match event {
            ParsedEvent::PoolCreation(pool_event) => self.validate_pool_creation(pool_event),
            _ => Ok(false),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    fn create_test_config() -> EventListenerConfig {
        EventListenerConfig {
            solana: crate::config::settings::SolanaConfig {
                rpc_url: "https://api.devnet.solana.com".to_string(),
                ws_url: "wss://api.devnet.solana.com".to_string(),
                commitment: "confirmed".to_string(),
                program_id: Pubkey::from_str("FA1RJDDXysgwg5Gm3fJXWxt26JQzPkAzhTA114miqNUX").unwrap(),
                private_key: None,
            },
            database: crate::config::settings::DatabaseConfig {
                uri: "mongodb://localhost:27017".to_string(),
                database_name: "test".to_string(),
                max_connections: 10,
                min_connections: 2,
            },
            listener: crate::config::settings::ListenerConfig {
                batch_size: 100,
                sync_interval_secs: 30,
                max_retries: 3,
                retry_delay_ms: 1000,
                signature_cache_size: 10000,
                checkpoint_save_interval_secs: 60,
                backoff: crate::config::settings::BackoffConfig::default(),
                batch_write: crate::config::settings::BatchWriteConfig::default(),
            },
            monitoring: crate::config::settings::MonitoringConfig {
                metrics_interval_secs: 60,
                enable_performance_monitoring: true,
                health_check_interval_secs: 30,
            },
        }
    }

    fn create_test_pool_creation_event() -> PoolCreationEvent {
        PoolCreationEvent {
            pool_address: Pubkey::new_unique(),
            token_a_mint: Pubkey::new_unique(),
            token_b_mint: Pubkey::new_unique(),
            token_a_decimals: 9,
            token_b_decimals: 6,
            fee_rate: 3000,              // 0.3%
            sqrt_price_x64: 1u128 << 64, // ‰ª∑Ê†º‰∏∫1.0
            tick: 0,
            creator: Pubkey::new_unique(),
            clmm_config: Pubkey::new_unique(),
            created_at: chrono::Utc::now().timestamp(),
        }
    }

    #[test]
    fn test_pool_creation_parser_creation() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        assert_eq!(parser.get_event_type(), "pool_creation");
        assert_eq!(parser.get_discriminator(), [89, 202, 187, 172, 108, 193, 190, 8]);
    }

    #[test]
    fn test_convert_to_parsed_event() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();
        let test_event = create_test_pool_creation_event();

        let parsed = parser.convert_to_parsed_event(test_event.clone(), "test_signature".to_string(), 12345);

        match parsed {
            ParsedEvent::PoolCreation(data) => {
                assert_eq!(data.pool_address, test_event.pool_address);
                assert_eq!(data.token_a_mint, test_event.token_a_mint);
                assert_eq!(data.token_b_mint, test_event.token_b_mint);
                assert_eq!(data.fee_rate, test_event.fee_rate);
                assert_eq!(data.fee_rate_percentage, 0.3);
                assert_eq!(data.signature, "test_signature");
                assert_eq!(data.slot, 12345);
            }
            _ => panic!("ÊúüÊúõPoolCreation‰∫ã‰ª∂"),
        }
    }

    #[tokio::test]
    async fn test_validate_pool_creation() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        let valid_event = PoolCreationEventData {
            pool_address: Pubkey::new_unique(),
            token_a_mint: Pubkey::new_unique(),
            token_b_mint: Pubkey::new_unique(),
            token_a_decimals: 9,
            token_b_decimals: 6,
            fee_rate: 3000,
            fee_rate_percentage: 0.3,
            annual_fee_rate: 109.5,
            pool_type: "Ê†áÂáÜË¥πÁéá".to_string(),
            sqrt_price_x64: 1u128 << 64,
            initial_price: 1.0,
            initial_tick: 0,
            creator: Pubkey::new_unique(),
            clmm_config: Pubkey::new_unique(),
            is_stable_pair: false,
            estimated_liquidity_usd: 0.0,
            created_at: chrono::Utc::now().timestamp(),
            signature: "test_sig".to_string(),
            slot: 12345,
            processed_at: chrono::Utc::now().to_rfc3339(),
        };

        assert!(parser.validate_pool_creation(&valid_event).unwrap());

        // ÊµãËØïÊó†Êïà‰∫ã‰ª∂ÔºàÁõ∏ÂêåÁöÑ‰ª£Â∏ÅÔºâ
        let invalid_event = PoolCreationEventData {
            token_b_mint: valid_event.token_a_mint, // Áõ∏ÂêåÁöÑ‰ª£Â∏Å
            ..valid_event.clone()
        };

        assert!(!parser.validate_pool_creation(&invalid_event).unwrap());
    }

    #[test]
    fn test_calculate_pool_metrics() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        let event = PoolCreationEvent {
            fee_rate: 3000,              // 0.3%
            sqrt_price_x64: 1u128 << 64, // sqrt(1.0)
            ..create_test_pool_creation_event()
        };

        let (price, annual_fee, pool_type) = parser.calculate_pool_metrics(&event);

        assert!((price - 1.0).abs() < 0.0001); // ‰ª∑Ê†ºÂ∫îËØ•Êé•Ëøë1.0
        assert_eq!(annual_fee, 109.5); // 0.3% * 365
        assert_eq!(pool_type, "Ê†áÂáÜË¥πÁéá");
    }

    #[test]
    fn test_borsh_serialization() {
        let event = create_test_pool_creation_event();

        // ÊµãËØïÂ∫èÂàóÂåñ
        let serialized = borsh::to_vec(&event).unwrap();
        assert!(!serialized.is_empty());

        // ÊµãËØïÂèçÂ∫èÂàóÂåñ
        let deserialized = PoolCreationEvent::try_from_slice(&serialized).unwrap();
        assert_eq!(deserialized.pool_address, event.pool_address);
        assert_eq!(deserialized.token_a_mint, event.token_a_mint);
        assert_eq!(deserialized.fee_rate, event.fee_rate);
    }

    #[tokio::test]
    async fn test_parse_from_logs_no_program_data() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        let logs = vec![
            "Program 11111111111111111111111111111111 invoke [1]".to_string(),
            "Program 11111111111111111111111111111111 success".to_string(),
        ];

        let result = parser.parse_from_logs(&logs, "test_sig", 12345).await.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn test_validate_event() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        let event = ParsedEvent::PoolCreation(PoolCreationEventData {
            pool_address: Pubkey::new_unique(),
            token_a_mint: Pubkey::new_unique(),
            token_b_mint: Pubkey::new_unique(),
            token_a_decimals: 9,
            token_b_decimals: 6,
            fee_rate: 3000,
            fee_rate_percentage: 0.3,
            annual_fee_rate: 109.5,
            pool_type: "Ê†áÂáÜË¥πÁéá".to_string(),
            sqrt_price_x64: 1u128 << 64,
            initial_price: 1.0,
            initial_tick: 0,
            creator: Pubkey::new_unique(),
            clmm_config: Pubkey::new_unique(),
            is_stable_pair: false,
            estimated_liquidity_usd: 0.0,
            created_at: chrono::Utc::now().timestamp(),
            signature: "test_sig".to_string(),
            slot: 12345,
            processed_at: chrono::Utc::now().to_rfc3339(),
        });

        assert!(parser.validate_event(&event).await.unwrap());
    }

    #[test]
    fn test_discriminator_mismatch_error() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        // ÂàõÂª∫‰∏Ä‰∏™Â∏¶ÊúâÈîôËØØdiscriminatorÁöÑbase64Êï∞ÊçÆ
        let mut data = vec![0u8; 100];
        // ËÆæÁΩÆ‰∏Ä‰∏™ÈîôËØØÁöÑdiscriminatorÔºà‰∏çÊòØÊ±†Â≠êÂàõÂª∫‰∫ã‰ª∂ÁöÑÔºâ
        data[0..8].copy_from_slice(&[99, 99, 99, 99, 99, 99, 99, 99]);

        let data_str = general_purpose::STANDARD.encode(&data);
        let result = parser.parse_program_data(&data_str);

        // È™åËØÅËøîÂõûÁöÑÊòØDiscriminatorMismatchÈîôËØØ
        assert!(matches!(result, Err(EventListenerError::DiscriminatorMismatch)));
    }

    #[tokio::test]
    async fn test_parse_from_logs_skips_discriminator_mismatch() {
        let config = create_test_config();
        let parser = PoolCreationParser::new(&config).unwrap();

        // ÂàõÂª∫‰∏Ä‰∏™Â∏¶ÊúâÈîôËØØdiscriminatorÁöÑÊó•Âøó
        let mut wrong_data = vec![0u8; 100];
        wrong_data[0..8].copy_from_slice(&[99, 99, 99, 99, 99, 99, 99, 99]);
        let wrong_log = format!("Program data: {}", general_purpose::STANDARD.encode(&wrong_data));

        // ÂàõÂª∫‰∏Ä‰∏™Ê≠£Á°ÆÁöÑÊó•ÂøóÔºà‰ΩÜÊ≤°ÊúâÂÆåÊï¥ÁöÑ‰∫ã‰ª∂Êï∞ÊçÆÔºåÂè™ÊòØ‰∏∫‰∫ÜÊµãËØïÊµÅÁ®ãÔºâ
        let logs = vec!["Some other log".to_string(), wrong_log, "Another log".to_string()];

        // Ëß£ÊûêÊó•ÂøóÔºåÂ∫îËØ•Ë∑≥Ëøádiscriminator‰∏çÂåπÈÖçÁöÑÊó•ÂøóÔºåËøîÂõûNoneÔºàÂõ†‰∏∫Ê≤°ÊúâÂåπÈÖçÁöÑ‰∫ã‰ª∂Ôºâ
        let result = parser.parse_from_logs(&logs, "test_signature", 12345).await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }
}

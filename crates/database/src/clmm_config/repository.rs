use anyhow::Result;
use futures::stream::TryStreamExt;
use mongodb::{
    bson::{doc, DateTime as BsonDateTime},
    Collection, IndexModel,
};
use tracing::{error, info};

use super::model::{ClmmConfigModel, ClmmConfigQuery, ClmmConfigStats};

/// CLMMÈÖçÁΩÆ‰ªìÂ∫ì
#[derive(Clone)]
pub struct ClmmConfigRepository {
    collection: Collection<ClmmConfigModel>,
}

impl ClmmConfigRepository {
    /// ÂàõÂª∫Êñ∞ÁöÑCLMMÈÖçÁΩÆ‰ªìÂ∫ì
    pub fn new(collection: Collection<ClmmConfigModel>) -> Self {
        Self { collection }
    }

    /// ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÁ¥¢Âºï
    pub async fn init_indexes(&self) -> Result<()> {
        info!("üîß ÂàùÂßãÂåñCLMMÈÖçÁΩÆÈõÜÂêàÁ¥¢Âºï...");

        let indexes = vec![
            // ÈÖçÁΩÆIDÂîØ‰∏ÄÁ¥¢Âºï
            IndexModel::builder()
                .keys(doc! { "configId": 1 })
                .options(
                    mongodb::options::IndexOptions::builder()
                        .unique(true)
                        .name("configId_unique".to_string())
                        .build(),
                )
                .build(),
            // Á¥¢ÂºïÂ≠óÊÆµÁ¥¢Âºï (ÂèØËÉΩ‰ºöÊü•ËØ¢)
            IndexModel::builder()
                .keys(doc! { "index": 1 })
                .options(
                    mongodb::options::IndexOptions::builder()
                        .name("index_1".to_string())
                        .build(),
                )
                .build(),
            // ÂêØÁî®Áä∂ÊÄÅÁ¥¢Âºï
            IndexModel::builder()
                .keys(doc! { "enabled": 1 })
                .options(
                    mongodb::options::IndexOptions::builder()
                        .name("enabled_1".to_string())
                        .build(),
                )
                .build(),
            // Â§çÂêàÁ¥¢ÂºïÔºöÂêØÁî®Áä∂ÊÄÅÂíåÁ¥¢Âºï
            IndexModel::builder()
                .keys(doc! { "enabled": 1, "index": 1 })
                .options(
                    mongodb::options::IndexOptions::builder()
                        .name("enabled_index_compound".to_string())
                        .build(),
                )
                .build(),
            // ÂàõÂª∫Êó∂Èó¥Á¥¢Âºï (Áî®‰∫éÊéíÂ∫è)
            IndexModel::builder()
                .keys(doc! { "createdAt": 1 })
                .options(
                    mongodb::options::IndexOptions::builder()
                        .name("createdAt_1".to_string())
                        .build(),
                )
                .build(),
        ];

        match self.collection.create_indexes(indexes, None).await {
            Ok(results) => {
                info!("‚úÖ CLMMÈÖçÁΩÆÁ¥¢ÂºïÂàõÂª∫ÊàêÂäü: {:?}", results.index_names);
                Ok(())
            }
            Err(e) => {
                error!("‚ùå CLMMÈÖçÁΩÆÁ¥¢ÂºïÂàõÂª∫Â§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// ‰øùÂ≠òCLMMÈÖçÁΩÆ (upsertÊìç‰Ωú)
    pub async fn save_config(&self, config: &ClmmConfigModel) -> Result<String> {
        let filter = doc! { "configId": &config.config_id };
        let update = doc! {
            "$set": mongodb::bson::to_document(config)?
        };

        let options = mongodb::options::UpdateOptions::builder()
            .upsert(true)
            .build();

        match self.collection.update_one(filter, update, options).await {
            Ok(result) => {
                if let Some(upserted_id) = result.upserted_id {
                    info!("‚úÖ Êñ∞Âª∫CLMMÈÖçÁΩÆ: {}", config.config_id);
                    Ok(upserted_id.to_string())
                } else {
                    info!("üîÑ Êõ¥Êñ∞CLMMÈÖçÁΩÆ: {}", config.config_id);
                    Ok(config.config_id.clone())
                }
            }
            Err(e) => {
                error!("‚ùå ‰øùÂ≠òCLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// ÊâπÈáè‰øùÂ≠òCLMMÈÖçÁΩÆ
    pub async fn save_configs(&self, configs: &[ClmmConfigModel]) -> Result<Vec<String>> {
        let mut saved_ids = Vec::new();

        for config in configs {
            match self.save_config(config).await {
                Ok(id) => saved_ids.push(id),
                Err(e) => {
                    error!("‚ùå ÊâπÈáè‰øùÂ≠òÈÖçÁΩÆ{}Â§±Ë¥•: {}", config.config_id, e);
                    return Err(e);
                }
            }
        }

        info!("‚úÖ ÊâπÈáè‰øùÂ≠ò{}‰∏™CLMMÈÖçÁΩÆÊàêÂäü", saved_ids.len());
        Ok(saved_ids)
    }

    /// Ê†πÊçÆÈÖçÁΩÆIDËé∑ÂèñÈÖçÁΩÆ
    pub async fn get_config_by_id(&self, config_id: &str) -> Result<Option<ClmmConfigModel>> {
        let filter = doc! { "configId": config_id };

        match self.collection.find_one(filter, None).await {
            Ok(config) => Ok(config),
            Err(e) => {
                error!("‚ùå Ê†πÊçÆIDËé∑ÂèñCLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// Ê†πÊçÆÁ¥¢ÂºïËé∑ÂèñÈÖçÁΩÆ
    pub async fn get_config_by_index(&self, index: u32) -> Result<Option<ClmmConfigModel>> {
        let filter = doc! { "index": index, "enabled": true };

        match self.collection.find_one(filter, None).await {
            Ok(config) => Ok(config),
            Err(e) => {
                error!("‚ùå Ê†πÊçÆÁ¥¢ÂºïËé∑ÂèñCLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// Ëé∑ÂèñÊâÄÊúâÂêØÁî®ÁöÑÈÖçÁΩÆ
    pub async fn get_all_enabled_configs(&self) -> Result<Vec<ClmmConfigModel>> {
        let filter = doc! { "enabled": true };
        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "index": 1 })
            .build();

        match self.collection.find(filter, options).await {
            Ok(cursor) => {
                let configs: Vec<ClmmConfigModel> = cursor.try_collect().await?;
                Ok(configs)
            }
            Err(e) => {
                error!("‚ùå Ëé∑ÂèñÊâÄÊúâÂêØÁî®ÁöÑCLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// Êü•ËØ¢ÈÖçÁΩÆÂàóË°® (ÊîØÊåÅÂàÜÈ°µÂíåËøáÊª§)
    pub async fn query_configs(&self, query: &ClmmConfigQuery) -> Result<Vec<ClmmConfigModel>> {
        let mut filter = doc! {};

        // ÊûÑÂª∫ËøáÊª§Êù°‰ª∂
        if let Some(config_id) = &query.config_id {
            filter.insert("configId", config_id);
        }
        if let Some(index) = query.index {
            filter.insert("index", index);
        }
        if let Some(enabled) = query.enabled {
            filter.insert("enabled", enabled);
        }

        // ÂàÜÈ°µÂèÇÊï∞
        let page = query.page.unwrap_or(1).max(1);
        let limit = query.limit.unwrap_or(20).min(100); // ÊúÄÂ§ß100Êù°
        let skip = (page - 1) * limit;

        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "index": 1 })
            .skip(skip as u64)
            .limit(limit)
            .build();

        match self.collection.find(filter, options).await {
            Ok(cursor) => {
                let configs: Vec<ClmmConfigModel> = cursor.try_collect().await?;
                Ok(configs)
            }
            Err(e) => {
                error!("‚ùå Êü•ËØ¢CLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// Ëé∑ÂèñÈÖçÁΩÆÁªüËÆ°‰ø°ÊÅØ
    pub async fn get_config_stats(&self) -> Result<ClmmConfigStats> {
        // ÊÄªÈÖçÁΩÆÊï∞Èáè
        let total_configs = self.collection.count_documents(doc! {}, None).await? as u64;

        // ÂêØÁî®ÁöÑÈÖçÁΩÆÊï∞Èáè
        let enabled_configs = self.collection.count_documents(doc! { "enabled": true }, None).await? as u64;

        // Á¶ÅÁî®ÁöÑÈÖçÁΩÆÊï∞Èáè
        let disabled_configs = total_configs - enabled_configs;

        // ÊúÄÂêéÂêåÊ≠•Êó∂Èó¥
        let last_sync_filter = doc! { "lastSyncAt": { "$exists": true } };
        let last_sync_options = mongodb::options::FindOneOptions::builder()
            .sort(doc! { "lastSyncAt": -1 })
            .projection(doc! { "lastSyncAt": 1 })
            .build();

        let last_sync_time = match self.collection.find_one(last_sync_filter, last_sync_options).await? {
            Some(config) => config.last_sync_at,
            None => None,
        };

        Ok(ClmmConfigStats {
            total_configs,
            enabled_configs,
            disabled_configs,
            last_sync_time,
        })
    }

    /// Á¶ÅÁî®ÈÖçÁΩÆ
    pub async fn disable_config(&self, config_id: &str) -> Result<bool> {
        let filter = doc! { "configId": config_id };
        let update = doc! {
            "$set": {
                "enabled": false,
                "updatedAt": BsonDateTime::now()
            }
        };

        match self.collection.update_one(filter, update, None).await {
            Ok(result) => {
                if result.matched_count > 0 {
                    info!("‚úÖ Á¶ÅÁî®CLMMÈÖçÁΩÆ: {}", config_id);
                    Ok(true)
                } else {
                    info!("‚ö†Ô∏è Êú™ÊâæÂà∞Ë¶ÅÁ¶ÅÁî®ÁöÑCLMMÈÖçÁΩÆ: {}", config_id);
                    Ok(false)
                }
            }
            Err(e) => {
                error!("‚ùå Á¶ÅÁî®CLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// ÂêØÁî®ÈÖçÁΩÆ
    pub async fn enable_config(&self, config_id: &str) -> Result<bool> {
        let filter = doc! { "configId": config_id };
        let update = doc! {
            "$set": {
                "enabled": true,
                "updatedAt": BsonDateTime::now()
            }
        };

        match self.collection.update_one(filter, update, None).await {
            Ok(result) => {
                if result.matched_count > 0 {
                    info!("‚úÖ ÂêØÁî®CLMMÈÖçÁΩÆ: {}", config_id);
                    Ok(true)
                } else {
                    info!("‚ö†Ô∏è Êú™ÊâæÂà∞Ë¶ÅÂêØÁî®ÁöÑCLMMÈÖçÁΩÆ: {}", config_id);
                    Ok(false)
                }
            }
            Err(e) => {
                error!("‚ùå ÂêØÁî®CLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }

    /// Ê£ÄÊü•ÊòØÂê¶ÊúâÈÖçÁΩÆÊï∞ÊçÆ
    pub async fn has_configs(&self) -> Result<bool> {
        let count = self.collection.count_documents(doc! {}, None).await?;
        Ok(count > 0)
    }

    /// Ê∏ÖÁ©∫ÊâÄÊúâÈÖçÁΩÆ (Ë∞®ÊÖé‰ΩøÁî®)
    pub async fn clear_all_configs(&self) -> Result<u64> {
        match self.collection.delete_many(doc! {}, None).await {
            Ok(result) => {
                info!("üóëÔ∏è Ê∏ÖÁ©∫ÊâÄÊúâCLMMÈÖçÁΩÆÔºåÂà†Èô§Êï∞Èáè: {}", result.deleted_count);
                Ok(result.deleted_count)
            }
            Err(e) => {
                error!("‚ùå Ê∏ÖÁ©∫CLMMÈÖçÁΩÆÂ§±Ë¥•: {}", e);
                Err(e.into())
            }
        }
    }
}